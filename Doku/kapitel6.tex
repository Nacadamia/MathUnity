% !TeX root = Bachelorarbeit.tex
\chapter{Fazit und R\'{e}sum\'{e}}
\label{Fazit und R\'{e}sum\'{e}}

Die Fallstudie \emph{Bustracker} wurde mit folgendem Ziel begonnen: \glqq \emph{Mit Hilfe von mobilen Geräten realisieren wir eine Tracking-Möglichkeit für Kinder, die durch einen Bustransport in ländlichen Regionen auf dem Weg zum oder vom Kindergarten, Grundschule oder auch weiterführende Schule befinden.}\grqq{}

Zu diesem Zwecke wurde eine plattformübergreifend lauffähige Applikation für Mobilgeräte vollständig neu entwickelt. Zur Positionsbestimmung werden \gls{gls:gps} und iBeacons verwendet. Die Applikation, ausgeführt als Single Page Application, zeigt die Machbarkeit und kann in Zukunft unter realen Bedingungen getestet werden. 
 
\emph{Bustracker} existiert als Prototyp. Es ist nun möglich, ein Kind auf seinem Weg zur oder von der Betreuung zu beobachten. Die Kombination aus \gls{gls:gps} und iBeacons hat sich als zweckmäßig und vorteilhaft erwiesen. 


\section{Lessons learned}
\label{Lessons learned}

In diesem Abschnitt werden die  im Laufe der Entwicklung aufgetretenen Probleme sowie deren Lösungen diskutiert.  

\subsection{Marker eignen sich nicht zum Anzeigen von Wegen}
Zu Beginn der Entwicklung wurde der Ansatz verfolgt, einzelne Marker in Reihe anzuordnen und so den Fahrweg nachzuvollziehen. Mit Hilfe der \emph{makeTrack(LatLng)}-Methode wurde bei jeder neuen Positionsbestimmung ein Marker auf der Map erzeugt (Listing \ref{lst:makeTrack}). Einige wenige Marker lassen sich ohne Performanceverlust beim scrollen darstellen. Steigt die Zahl der Marker jedoch an, so kommt es zu einer ruckelnden Darstellung. Die Performance der Karte beim Scrollen innerhalb und außerhalb der Karte nahm stark ab, bis hin zur Unzumutbarkeit für den Nutzer.

\begin{lstlisting}[float, language= JavaScript, caption= Erstellen einzelner Marker, label=lst:makeTrack]
  makeTrack(latlong:LatLng){
    let moptions= {
    title:'Strecke',
   snippet: 'Hier faehrt der Bus!',
   position: latlong,
   animation: GoogleMapsAnimation.BOUNCE
  } 
\end{lstlisting}

Als erste Gegenmaßnahme wurde die Darstellung der Marker analog zum Gameloop Konzept verwendet. In ihrer Veröffentlichung  \emph{\textbf{Real Time Game Loop Models for Single-Player Computer Games}} \cite{valente2005real} schreiben die Autoren in Kapitel 2.1, dass die einfachste Game Loop aus den Schritten \glqq User Input\grqq{}, dem\glqq Update\grqq{} und dem \glqq Rendern\grqq{} besteht. In \emph{Bustracker} wäre der User Input die neue Position, das Update wäre das aktualisierte Array und das Rendern der Aufruf einer Methode zum Darstellen einer Gruppe von Markern, eines sogenannten Clusters.
Eine Testimplementierung zeigte bereits zu Beginn, dass hierdurch kein Performancegewinn zu erzielen ist.  

Als Lösung wurde der Weg über die Polyline gewählt. Die Polyline ist eine Linie, welche die sie definierenden Punkte verbindet. Das Zeichen einer Linie beansprucht wesentlich weniger Ressourcen als das Zeichnen einer Grafik in Form eines Markers für jeden einzelnen Punkt. Listing \ref{lst:polyline} zeigt die Verwendung der Polyline.
\vspace{12px}
\begin{lstlisting}[language= JavaScript, caption= Zeichnen einer Polyline auf einer Google Map, label=lst:polyline]
makePolyFromArray(array: any[]){
this._map.addPolyline({
points: array,
'color' : '#AA00FF',
'width': 10,
'geodesic': true
});}
\end{lstlisting}
Die Punkte werden als Array vom Typ LatLng[] übegeben. 

Weitere Parameter sind: 
\begin{itemize}
\item[\textbf{color}]
Farbe der Linie in Hexadezimalschreibweise
\item[\textbf{width}]
Breite der Linie in Pixel
\item[\textbf{geodesic}]
Falls true gewählt ist, passt sich die Linie der Erdkrümmung an.
\end{itemize}

\subsection{Polyline wurde nicht gezeichnet, maximal 100 Punkte sind erlaubt}
Um den zurückgelegten Pfad vom beobachteten Nutzer an den Straßenverlauf anzupassen, wird die Google Maps Roads API \cite{RoadsAPIDoc} verwendet. Diese nimmt eine Menge von LatLong Koordinaten entgegen und interpoliert, wenn gewählt, die Strecke mit zusätzlichen Punkten. Diese Punkte werden im \gls{gls:json}-Format zurückgegeben und können zur Darstellung einer Linie auf der Karte verwendet werden.

\begin{lstlisting}[float, language= JavaScript, caption= Verwendung der RoadsAPI durch \emph{Bustracker}, label=lst:MapsApi]
snapToRoad(dinger: LatLng[]): Promise<LatLng[]> { 
  console.log('Hello SnapToRoad');
  let prom = new Promise<LatLng[]>((resolve, reject) => {
  let payload: string = '';
  let ret: LatLng[] = [];
  for (let i: number = 1; i <= 100; i++) {
    payload = payload + dinger[i].lat + ',' + dinger[i].lng;
    if (i < 100)
    payload = payload + '\|';
  }
    this.http.get('https://roads.googleapis.com/v1/snapToRoads?path=' + payload
    + '&interpolate=true&key=<Der API-Key>').subscribe((data) => {
    data['snappedPoints'].forEach((itr) => {
    ret.push(new LatLng(itr.location.latitude, itr.location.longitude));
  });
      resolve(ret);
    }), (err) => {
        reject('Fehler beim SnapToRoad' + JSON.stringify(err));
      };
   });
    console.log('Bye SnapToRoad');
    return prom;
  }
}
\end{lstlisting}

Listing \ref{lst:MapsApi} zeigt die Methode, die eine Menge von LatLong-Koordianten an die Google Maps Roads \gls{gls:API} übergibt und die Antwort in Form eines Promise zurückgibt. Die ersten Versuche, die Koordinaten aus der \emph{Bustracker}-\gls{gls:API} zu verwenden, führten nicht zum Erfolg. Nach Einfügen von Konsolenausgaben und teilweisem Auskommentieren von Code wurde ersichtlich, dass der Fehler im Bereich des GET-Requests lag. Um das \glqq err \grqq{} Objekt auf der Konsole lesbar auszugeben, wird es mit Hilfe der \emph{JSON.stringify()}-Methode in einen String umgewandelt. Aus der Fehlermeldung ging hervor, dass die Anzahl der an die Google Maps Road \gls{gls:API} übergebenen Punkte zu hoch ist, maximal 100 sind erlaubt. Um diesem Umstand Rechnung zu tragen wurden die Zeilen 6 -10 aus dem Listing \ref{lst:MapsApi} eingefügt. Diese Schleife sorgt nun dafür, dass nur die letzten 100 Elemente an die Google Maps \gls{gls:API} geschickt werden. Die Strecke wird sukzessive in Abschnitten gezeichnet.

\subsection{API-KEY für native Android und iOS Anwendungen}
Bei der Installation des Google Maps Plugins \cite{GoogleMapsPluginDoku} muss im Konsolenbefehl (Listing \ref{lst:mapsPlugin}) der API-Key für die jeweilige Plattform angegeben werden.



\begin{lstlisting}[float,language= Bash, caption= CLI Befehle - Installation Google Maps Plugin , label=lst:mapsPlugin]
$ ionic cordova plugin add cordova-plugin-googlemaps --variable API_KEY_FOR_ANDROID="YOUR_ANDROID_API_KEY_IS_HERE" --variable API_KEY_FOR_IOS="YOUR_IOS_API_KEY_IS_HERE"
$ npm install --save @ionic-native/google-maps
\end{lstlisting}

Dieser Key ist über die Google Developer Konsole \cite{GoogleDevConsole} einzurichten und zu beziehen. Googles  Dokumentation zu Maps enthält eine ausführliche Anleitung zum Erzeugen von Keys. \cite{GoogleGetKey}.


\section{Ausblick}
\label{sec:Ausblick}
Die Anwendung wird kontinuierlich weiterentwickelt und neue Features werden implementiert. An dieser Stelle wird ein Überblick über weitere Entwicklungsmöglichkeiten von \emph{Bustracker} gegeben.

\subsection[Freies Kartenmaterial]{Umstellung auf freies Kartenmaterial}
Um in Zukunft weniger abhängig von Google und deren \glspl{gls:API} zu sein, soll die Anwendung auf freies Kartenmaterial umgestellt werden. Das Kartenmaterial soll von \gls{gls:OSM} bezogen werden \cite{OSM}. Das Anpassen an den Straßenverlauf soll mittels der \gls{gls:OSRM} \cite{OSRM} durchgeführt werden. 

\subsection[Ankunftszeitberechnung]{Berechung der Ankuftszeit am Ziel}
Ein geplantes Feature ist die Berechnung der Ankunftszeit an einem Ziel. Dem Beobachter soll mitgeteilt werden, zu welcher Zeit die Ankunft am Ziel erwartet wird. Zunächst soll dies mit Hilfe der Google Distance \gls{gls:API} gelöst werden. In einer späteren Iteration soll dies ebenfalls unter Verwendung der \gls{gls:OSRM} durchgeführt werden. 

\subsection{Nutzerauthentifizierung}
Zukünftig soll eine Authentifizierung durchgeführt werden, um nur befugte Beobachter für ein bestimmtes Gerät zuzulassen.
Verschiedene Lösungen sind denkbar, z. B. das Generieren eines einzigartigen Schlüssels für jeden einzelnen Trackingvorgang. 
Denkbar ist auch eine Konfiguration einer Art Familie, in der einzelne Geräte einem Beobachter zugewiesen werden können.

\subsection{Sparchassistentenunterstützung}
Es wäre denkbar, die Datenbankeinträge des Servers mittels sogenannter Skills für Sprachassistenten abzurufen. Die rein auditive Darstellung könnte die momentane geocodierte Position bzw. den jeweiligen Checkpoint enthalten. 

\section{Fazit}
\label{Fazit}

\emph{Bustracker} ist ein Beispiel für eine Anwendung im Rahmen der Digitalisierung des ländlichen Raumes. Zurzeit ist die Anwendung im Status eines Prototyps. Durch kontinuierliche Weiterentwicklung, vor allem das Einarbeiten der im Ausblick genannten Features und Anpassungen an zukünftig evaluierten Nutzungsszenarien, wird \emph{Bustracker} zu einer höheren Sicherheit auf dem Schulweg beitragen.
